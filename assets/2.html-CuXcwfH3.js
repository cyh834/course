import{_ as i}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as e,o as l,d as a,a as s,e as n}from"./app-D3S8dQv2.js";const p={},d=a(`<p>主要参考<a href="http://makefiletutorial.foofun.cn/" target="_blank" rel="noopener noreferrer">Makefile Tutorial</a>, <a href="https://blog.csdn.net/wohu1104/article/details/110905996" target="_blank" rel="noopener noreferrer">浅显易懂 Makefile 入门</a>和<a href="https://blog.csdn.net/challenglistic/article/details/129590846" target="_blank" rel="noopener noreferrer">makefile函数</a></p><h2 id="makefile简介" tabindex="-1"><a class="header-anchor" href="#makefile简介"><span>Makefile简介</span></a></h2><p>Makefile是一个用来自动化编译C/C++项目的文件。Makefile 文件描述了 Linux 系统下 C/C++ 工程的编译规则，一旦编写好 Makefile 文件，只需要一个 make 命令，整个工程就开始自动编译，不再需要手动执行 GCC 命令。一个中大型 C/C++ 工程的源文件有成百上千个，它们按照功能、模块、类型分别放在不同的目录中，Makefile 文件定义了一系列规则，指明了源文件的编译顺序、依赖关系、是否需要重新编译等。</p><p>##为什么需要Makefiles? 以 Linux 下的 C 语言开发为例来具体说明一下，多文件编译生成一个文件，编译的命令如下所示：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>gcc -o outfile name1.c name2.c ...</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>outfile 要生成的可执行程序的名字，nameN.c 是源文件的名字。这是我们在 Linux 下使用 gcc 编译器编译 C 文件的例子。如果我们遇到的源文件的数量不是很多的话，可以选择这样的编译方式。如果源文件非常的多的话，就会遇到下面的这些问题。</p><p>###编译的时候需要链接库的的问题 下面列举了一些需要我们手动链接的标准库：</p><pre><code>- name1.c 用到了数学计算库 math 中的函数，我们得手动添加参数 -lm；
- name4.c 用到了小型数据库 SQLite 中的函数，我们得手动添加参数 -lsqlite3；
- name5.c 使用到了线程，我们需要去手动添加参数 -lpthread；
</code></pre><p>因为有很多的文件，还要去链接很多的第三方库。所以在编译的时候命令会很长，并且在编译的时候我们可能会涉及到文件链接的顺序问题，所以手动编译会很麻烦。</p><p>如果我们学会使用 Makefile 就不一样了，它会彻底简化编译的操作。把要链接的库文件放在 Makefile 中，制定相应的规则和对应的链接顺序。这样只需要执行 make 命令，工程就会自动编译，省略掉手动编译中的参数选项和命令，非常的方便。</p><p>###编译大的工程会花费很长的时间 Makefile 支持多线程并发操作，会极大的缩短我们的编译时间，并且当我们修改了源文件之后，编译整个工程的时候，make 命令只会编译我们修改过的文件，没有修改的文件不用重新编译，也极大的解决了我们耗费时间的问题。</p><p>并且文件中的 Makefile 只需要完成一次，一般我们只要不增加或者是删除工程中的文件，Makefile 基本上不用去修改，编译时只用一个 make 命令。为我们提供了极大的便利，很大程度上提高编译的效率。</p><p>##Makefile规则 它的规则主要是两个部分组成，分别是依赖的关系和执行的命令，其结构如下所示：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>targets: prerequisites</span></span>
<span class="line"><span>	command</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>相关说明如下：</p><pre><code>- targets：规则的目标，是必须要有的，可以是 Object File（一般称它为中间文件），也可以是可执行文件，还可以是一个标签；
- prerequisites：是我们的依赖文件，要生成 targets 需要的文件或者是目标。可以是多个，用空格隔开，也可以是没有；
- command：make 需要执行的命令（任意的 shell 命令）。可以有多条命令，每一条命令占一行；
</code></pre><p>如果 command 太长, 可以用 \\ 作为换行符。</p><div class="hint-container important"><p class="hint-container-title">注意!</p><ul><li>我们的目标和依赖文件之间要使用冒号分隔开，命令的开始一定要使用 Tab 键，不能使用空格键。</li></ul></div><p>##运行示例 要运行这些示例，你需要安装一个终端并安装好“make”。</p><p>###make 安装：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>sudo apt-get install make</span></span>
<span class="line"><span>make -v		// 查看是否安装成功</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>对于每个示例，请将内容放在一个名为Makefile的文件中，并在该目录中运行命令make。 让我们从最简单的Makefiles开始:</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>hello:</span></span>
<span class="line"><span>	echo &quot;Hello, World&quot;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>下面是运行上述示例的输出:</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>$ make</span></span>
<span class="line"><span>echo &quot;Hello, World&quot;</span></span>
<span class="line"><span>Hello, World</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里已经包含很多东西了。 让我们分解一下:</p><ul><li>我们有一个 targe 叫做&quot;hello&quot;</li><li>这个目标有一个 commands</li><li>这个目标没有prerequisites（先决条件） 然后我们运行 make hello。 只要hello文件不存在，命令就会运行。 如果 hello 已存在，则不会运行任何命令。</li></ul><p>需要注意的是，我所说的hello既是一个目标，也是一个文件。 那是因为两者直接绑在一起。 通常，当目标运行时(也就是运行目标的命令时)，这些命令将创建一个与目标同名的文件。 目前hello &quot;target&quot; 还不会创建 hello 文件。</p><div class="hint-container important"><p class="hint-container-title">注意!</p><p>在Makefile中为了区分目标和文件，通常定义完目标后会在.PHONY: 后面加上目标名，从而提醒Makefile这是目标而不是文件，避免了目标名和文件名重合的情况导致编译错误。如：</p><p>.PHONY: hello</p></div><p>让我们创建一个更典型的Makefile - 一个编译单个C文件的Makefile。 但是在执行此操作之前，请创建一个名为 “blah.c” 的文件，其中包含以下内容:</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>// blah.c</span></span>
<span class="line"><span>int main() { return 0; }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>然后创建Makefile(和往常一样称为Makefile)：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>blah:</span></span>
<span class="line"><span>	cc blah.c -o blah</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>这次，尝试简单地运行 “make”。 由于没有将目标作为参数提供给make命令，因此会运行第一个目标。 在这种情况下，只有一个目标 (blah)。 第一次运行此命令时，将创建blah。 第二次运行，你会看到 make: &#39;blah&#39; is up to date。 这是因为blah文件已经存在。 但是有一个问题: 如果我们修改 blah.c，然后运行 make，还是什么都不会被重新编译。</p><p>我们通过添加一个先决条件来解决这个问题：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>blah: blah.c</span></span>
<span class="line"><span>	cc blah.c -o blah</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>当我们再次运行 make 时，会发生以下一组步骤:</p><ul><li>第一个目标被选中，因为第一个目标是默认目标</li><li>这有一个 “blah.c” 的先决条件</li><li>make决定是否应该运行blah目标。 只有当 blah.c 不存在，或者 blah.c 比 *blah 更新时，它才会运行 这最后一步是至关重要的，也是make的本质。 它试图做的是确定自上一次编译blah以来，blah的先决条件是否发生了变化。 也就是说，如果修改了 blah.c，运行 make 应该重新编译文件。 反之，如果blah.c没有变化，则无需重新编译。</li></ul><p>为了实现这一目标，它使用文件系统时间戳作为代理来确定某些内容是否已更改。 这是一个合理的启发式方法，因为文件时间戳通常只有在文件被修改时才会更改。 但重要的是要意识到情况并不总是如此。 例如，你可以修改一个文件，然后将该文件修改后的时间戳更改为旧的时间戳。 如果这样做，Make则会错误地猜测文件没有更改，因此可以忽略。</p><p>##make clean clean通常用作删除其他目标的输出的目标，但它在make中并不是一个专有的词。 你可以在此运行 make 和 make clean 来创建和删除 some_file。</p><p>请注意，clean在这里做了两件新的事情：</p><ul><li>它不是第一个目标 (默认目标)，也不是先决条件。 这意味着除非显式调用make clean，否则它永远不会运行</li></ul><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>some_file: </span></span>
<span class="line"><span>	touch some_file</span></span>
<span class="line"><span></span></span>
<span class="line"><span>clean:</span></span>
<span class="line"><span>	rm -f some_file</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>##实战分析 选自nemu/scripts/build.mk</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>.DEFAULT_GOAL = app</span></span>
<span class="line"><span></span></span>
<span class="line"><span># Add necessary options if the target is a shared library</span></span>
<span class="line"><span>ifeq ($(SHARE),1)</span></span>
<span class="line"><span>SO = -so</span></span>
<span class="line"><span>PROJECT = $(NEMU_HOME)/src/monitor/sdb</span></span>
<span class="line"><span>CFLAGS  += -fPIC -fvisibility=hidden -I$(PROJECT)</span></span>
<span class="line"><span>LDFLAGS += -shared -fPIC</span></span>
<span class="line"><span>endif</span></span>
<span class="line"><span></span></span>
<span class="line"><span>WORK_DIR  = $(shell pwd)</span></span>
<span class="line"><span>BUILD_DIR = $(WORK_DIR)/build</span></span>
<span class="line"><span></span></span>
<span class="line"><span>INC_PATH := $(WORK_DIR)/include $(INC_PATH) $(NEMU_HOME)/src $(NEMU_HOME)/include</span></span>
<span class="line"><span>OBJ_DIR  = $(BUILD_DIR)/obj-$(NAME)$(SO)</span></span>
<span class="line"><span>BINARY   = $(BUILD_DIR)/$(NAME)$(SO)</span></span>
<span class="line"><span></span></span>
<span class="line"><span># Compilation flags</span></span>
<span class="line"><span>ifeq ($(CC),clang)</span></span>
<span class="line"><span>CXX := clang++</span></span>
<span class="line"><span>else</span></span>
<span class="line"><span>CXX := g++</span></span>
<span class="line"><span>endif</span></span>
<span class="line"><span>LD := $(CXX)</span></span>
<span class="line"><span>INCLUDES = $(addprefix -I, $(INC_PATH))</span></span>
<span class="line"><span>CFLAGS  := -O2 -MMD -Wall -Werror $(INCLUDES) $(CFLAGS)</span></span>
<span class="line"><span>LDFLAGS := -O2 $(LDFLAGS)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>OBJS = $(SRCS:%.c=$(OBJ_DIR)/%.o) $(CXXSRC:%.cc=$(OBJ_DIR)/%.o)</span></span>
<span class="line"><span></span></span>
<span class="line"><span># Compilation patterns</span></span>
<span class="line"><span>$(OBJ_DIR)/%.o: %.c</span></span>
<span class="line"><span>	@echo + CC $&lt;</span></span>
<span class="line"><span>	@mkdir -p $(dir $@)</span></span>
<span class="line"><span>	@$(CC) $(CFLAGS) -c -o $@ $&lt;</span></span>
<span class="line"><span>	$(call call_fixdep, $(@:.o=.d), $@)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>$(OBJ_DIR)/%.o: %.cc</span></span>
<span class="line"><span>	@echo + CXX $&lt;</span></span>
<span class="line"><span>	@mkdir -p $(dir $@)</span></span>
<span class="line"><span>	@$(CXX) $(CFLAGS) $(CXXFLAGS) -c -o $@ $&lt;</span></span>
<span class="line"><span>	$(call call_fixdep, $(@:.o=.d), $@)</span></span>
<span class="line"><span></span></span>
<span class="line"><span># Depencies</span></span>
<span class="line"><span>-include $(OBJS:.o=.d)</span></span>
<span class="line"><span></span></span>
<span class="line"><span># Some convenient rules</span></span>
<span class="line"><span>counts:</span></span>
<span class="line"><span>	find -name &quot;*.c&quot; -o -name &quot;*.h&quot; | xargs cat | wc -l</span></span>
<span class="line"><span></span></span>
<span class="line"><span>countns:</span></span>
<span class="line"><span>	find -name &quot;*.c&quot; -o -name &quot;*.h&quot; | xargs cat | grep -v &#39;^$$&#39; | wc -l</span></span>
<span class="line"><span></span></span>
<span class="line"><span>.PHONY: app clean counts countns</span></span>
<span class="line"><span></span></span>
<span class="line"><span>app: $(BINARY)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>$(BINARY):: $(OBJS) $(ARCHIVES)</span></span>
<span class="line"><span>	@echo + LD $@</span></span>
<span class="line"><span>	@$(LD) -o $@ $(OBJS) $(LDFLAGS) $(ARCHIVES) $(LIBS)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>clean:</span></span>
<span class="line"><span>	-rm -rf $(BUILD_DIR)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,45),c=s("ul",null,[s("li",null,[s("em",null,".DEFAULT_GOAL = app."),n(" 设置默认目标为 app，即在运行 make 时，如果没有指定目标，将会构建 app。")]),s("li",null,[s("em",null,"ifeq ($(SHARE),1)"),n(" 如果环境变量 SHARE 的值为 1，则执行以下代码块，表示要构建一个共享库。")]),s("li",null,[s("em",null,"SO = -so"),n(" SO 设置为 -so，用于标识共享库。")]),s("li",null,[s("em",null,"PROJECT = $(NEMU_HOME)/src/monitor/sdb"),n(" PROJECT 定义了项目的路径。")]),s("li",null,[s("em",null,"CFLAGS += -fPIC -fvisibility=hidden -I$(PROJECT), LDFLAGS += -shared -fPIC"),n(" CFLAGS 添加了编译选项 -fPIC（生成位置无关代码）和 -fvisibility=hidden（默认隐藏符号），并包含了项目的头文件路径。 LDFLAGS 添加了链接选项 -shared（生成共享库）和 -fPIC。")]),s("li",null,[s("em",null,"endif"),n(" 结束条件判断。")]),s("li",null,[s("em",null,"WORK_DIR = $(shell pwd), BUILD_DIR = $(WORK_DIR)/build"),n(" WORK_DIR 获取当前工作目录。BUILD_DIR 定义了构建输出目录为 build，位于工作目录下。")]),s("li",null,[s("em",null,"INC_PATH := $(WORK_DIR)/include $(INC_PATH) $(NEMU_HOME)/src $(NEMU_HOME)/include"),n("INC_PATH 定义了包含路径，包含当前工作目录的 include 目录、之前定义的 INC_PATH、以及 NEMU 的源代码和包含目录。")]),s("li",null,"*INCLUDES = $(addprefix -I, $(INC_PATH))*INCLUDES 为包含路径添加 -I 前缀。"),s("li",null,[n("*OBJS = "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mo",{stretchy:"false"},"("),s("mi",null,"S"),s("mi",null,"R"),s("mi",null,"C"),s("mi",null,"S"),s("mo",null,":")]),s("annotation",{encoding:"application/x-tex"},"(SRCS:%.c=")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mopen"},"("),s("span",{class:"mord mathnormal",style:{"margin-right":"0.05764em"}},"SRCS"),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),s("span",{class:"mrel"},":")])])]),n("(OBJ_DIR)/%.o) "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mo",{stretchy:"false"},"("),s("mi",null,"C"),s("mi",null,"X"),s("mi",null,"X"),s("mi",null,"S"),s("mi",null,"R"),s("mi",null,"C"),s("mo",null,":")]),s("annotation",{encoding:"application/x-tex"},"(CXXSRC:%.cc=")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mopen"},"("),s("span",{class:"mord mathnormal",style:{"margin-right":"0.07153em"}},"CXXSRC"),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),s("span",{class:"mrel"},":")])])]),n("(OBJ_DIR)/%.o)*OBJS 定义了所有对象文件的列表，将源文件 SRCS 和 C++ 源文件 CXXSRC 转换为对应的对象文件路径。")]),s("li",null,[s("em",null,"$(OBJ_DIR)/%.o: %.c"),n("任意的.o文件都依赖于任意的.c文件")]),s("li",null,"*@echo + CC $<*打印正在编译的文件"),s("li",null,"*@mkdir -p $(dir $@)*创建对象文件的目录。"),s("li",null,"*@$(CC) $(CFLAGS) -c -o $@ $<*编译源文件为对象文件。"),s("li",null,"*$(call call_fixdep, $(@:.o=.d), $@)*调用自定义函数处理依赖关系。"),s("li",null,"*-include $(OBJS:.o=.d)*包含生成的依赖文件，以确保在源文件更改时重新编译。"),s("li",null,[s("em",null,".PHONY: app clean counts countns"),n("声明 app、clean、counts 和 countns 为伪目标，表示这些目标不对应实际文件。 其余的大致相同")])],-1),t=a('<p>##Makefile 常用函数汇总 ###makefile 函数格式：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>$(&lt;function&gt;, &lt;argument1&gt;, &lt;argument2&gt; ...)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>###名称处理函数</p><ul><li>wildcard : 获取指定格式的文件列表</li><li>dir : 获取文件所在目录</li><li>notdir : 获取文件路径非目录部分</li><li>suffix : 获取文件后缀</li><li>basename : 去除文件后缀</li></ul><p>###字符串替换与分析函数</p><ul><li>subst : 直接替换字符</li><li>patsubst : 按格式替换字符</li><li>$(C_SOURCES:.c=.o) : 按指定格式替换后缀</li><li>strip : 去掉开头和结尾的空白字符</li><li>findstring : 在某个字串中查找指定字符串</li><li>filter : 保留指定格式的字符串</li><li>filter-out : 去除指定格式的字符串</li><li>addprefix : 为字符串添加前缀</li></ul><p>###控制函数（信息打印函数）</p><ul><li>info : 打印提示信息</li><li>warning : 打印报警信息</li><li>errror : 打印错误信息</li></ul><p>###其他函数</p><ul><li>foreach : 循环函数</li><li>call : 调用函数</li><li>shell : 执行命令行命令</li></ul>',10),r=[d,c,t];function m(u,o){return l(),e("div",null,r)}const b=i(p,[["render",m],["__file","2.html.vue"]]),k=JSON.parse('{"path":"/software/Lab0/2.html","title":"Makefile","lang":"zh-CN","frontmatter":{"title":"Makefile","icon":"lightbulb"},"headers":[{"level":2,"title":"Makefile简介","slug":"makefile简介","link":"#makefile简介","children":[]}],"git":{"createdTime":1727152734000,"updatedTime":1727152734000,"contributors":[{"name":"EditorXu","email":"146361329+EditorXu@users.noreply.github.com","commits":1}]},"readingTime":{"minutes":9.4,"words":2819},"filePathRelative":"software/Lab0/2.md","localizedDate":"2024年9月24日"}');export{b as comp,k as data};
